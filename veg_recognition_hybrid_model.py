# -*- coding: utf-8 -*-
"""Veg_Recognition_hybrid_model_(2) (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11g_VpVUKBZEZKQUq53PJHii_HsVd_nq1
"""

import tensorflow as tf
from tensorflow.keras import layers,models,Sequential

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Convolution2D
from tensorflow.keras.layers import MaxPooling2D
from tensorflow.keras.layers import Flatten
from tensorflow.keras.layers import Dense,Dropout

import os
os.environ['KMP_DUPLICATE_LIB_OK']='True'

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import matplotlib.pyplot as plt
from keras.preprocessing.image import ImageDataGenerator

train_datagen = ImageDataGenerator(
                rescale=1. / 255,
                shear_range = 0.2,
                zoom_range =0.2,
                horizontal_flip = True)

training_set = train_datagen.flow_from_directory('/content/drive/MyDrive/bigdata/train',
                                        target_size = (128,128),
                                        batch_size = 2053,
                                        class_mode = 'categorical')


X_train, y_train = training_set.next()

print(X_train.shape)

print(y_train.shape)

y_train.shape

#Converting the testing image directory to numpy array


test_datagen = ImageDataGenerator(
                rescale=1. / 255) #Data Normalization

test_set = test_datagen.flow_from_directory('/content/drive/MyDrive/bigdata/Test',
                                        target_size = (128,128),
                                        batch_size = 600,
                                        class_mode = 'categorical')


X_test, y_test = test_set.next()

print(X_test.shape)

print(y_test.shape)

#VGG19 MODEL

from tensorflow.keras.applications.vgg19 import VGG19


base_model = VGG19(input_shape = (128, 128,3),
include_top = False,
weights = 'imagenet')

for layer in base_model.layers:
    layer.trainable = False

x = layers.Flatten()(base_model.output)

x = layers.Dense(512, activation='relu')(x)

x = layers.Dropout(0.5)(x)

x = layers.Dense(10, activation='sigmoid')(x)


model = tf.keras.models.Model(base_model.input, x)

model.compile(optimizer = tf.keras.optimizers.RMSprop(lr=0.0001),
              loss = 'categorical_crossentropy',metrics = ['accuracy'])

model.summary()

history = model.fit(X_train, y_train, epochs=30, validation_data=(X_test, y_test))
import matplotlib.pyplot as plt

#VGG16 MODEL

from tensorflow.keras.applications.vgg16 import VGG16


bas_model = VGG16(input_shape = (128, 128, 3),
include_top = False,
weights = 'imagenet')

for layer in bas_model.layers:
    layer.trainable = False

x = layers.Flatten()(bas_model.output)


x = layers.Dense(512, activation='relu')(x)


x = layers.Dropout(0.5)(x)


x = layers.Dense(10, activation='sigmoid')(x)



mode = tf.keras.models.Model(bas_model.input, x)

mode.compile(optimizer = tf.keras.optimizers.RMSprop(lr=0.0001),
              loss = 'categorical_crossentropy',metrics = ['accuracy'])

mode.summary();

history = mode.fit(X_train, y_train, epochs=30, validation_data=(X_test, y_test))
import matplotlib.pyplot as plt

#Inception V3

from tensorflow.keras.applications import InceptionV3
from tensorflow.keras.layers import Conv2D, GlobalAveragePooling2D,Input,Dense
base_model = InceptionV3(input_shape=(128, 128, 3), weights='imagenet', include_top=False)
from tensorflow.keras.models import Model
for layer in base_model.layers:
    layer.trainable = False
input_shape=(128,128,3)
input_layer = Input(input_shape)

features = base_model(input_layer)
num_classes=10

features = GlobalAveragePooling2D()(features)

output_layer = Dense(num_classes,activation='softmax')(features)
InceptionV3_model = Model(inputs=input_layer, outputs=output_layer)
InceptionV3_model.compile(optimizer = tf.keras.optimizers.RMSprop(lr=0.0001),
              loss = 'categorical_crossentropy',metrics = ['accuracy'])

InceptionV3_model.summary()
history=InceptionV3_model.fit(X_train, y_train, epochs=30, validation_data=(X_test, y_test))

#HYBRID MODEL

import tensorflow as tf
from tensorflow.keras.layers import Input, GlobalAveragePooling2D, concatenate, Dense
from tensorflow.keras.models import Model
from tensorflow.keras.applications import VGG16, VGG19
from tensorflow.keras.utils import to_categorical

input_shape = (128, 128, 3)

vgg16_base = VGG16(weights='imagenet', include_top=False, input_shape=input_shape)
vgg19_base = VGG19(weights='imagenet', include_top=False, input_shape=input_shape)
inceptionv3_base = InceptionV3(weights='imagenet', include_top=False, input_shape=input_shape)

for layer in vgg16_base.layers:
    layer.trainable = False

for layer in vgg19_base.layers:
    layer.trainable = False

for layer in inceptionv3_base.layers:
    layer.trainable = False

input_layer = Input(shape=input_shape)


vgg16_features = vgg16_base(input_layer)
vgg19_features = vgg19_base(input_layer)
inceptionv3_features = inceptionv3_base(input_layer)

vgg16_features = GlobalAveragePooling2D()(vgg16_features)
vgg19_features = GlobalAveragePooling2D()(vgg19_features)
inceptionv3_features = GlobalAveragePooling2D()(inceptionv3_features)

merged_features = concatenate([vgg16_features, vgg19_features, inceptionv3_features])

output_layer = Dense(1024, activation='relu')(merged_features)

output_layer = Dense(num_classes, activation='softmax')(output_layer)

hybrid_model = Model(inputs=input_layer, outputs=output_layer)

hybrid_model.compile(optimizer = tf.keras.optimizers.RMSprop(lr=0.0001),
              loss = 'categorical_crossentropy',metrics = ['accuracy'])

hybrid_model.summary()

history=hybrid_model.fit(X_train,y_train , epochs=30, validation_data=(X_test, y_test))

# Plot training & validation loss values
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend(['Train', 'Validation'], loc='upper right')
plt.show()

plt.plot(history.history['loss'])
plt.plot(history.history['val_accuracy'])
plt.title('Model Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend(['Train', 'Validation'], loc='upper right')
plt.show()

hybrid_model.evaluate(X_test,y_test)

plt.matshow(X_test[457])

y_pred = hybrid_model.predict(X_test)
y_pred[457]

for i in range(10):
    print(y_pred[457][i])

result = np.argmax(y_pred[457])
print(result)

classes = ['brinjal','colacesia','cucmber','drums','garlic','ladies finger','mirchi','onion','potato','tomata']

print(classes[result])